[gd_scene load_steps=4 format=3 uid="uid://cfwfg80xw3aw2"]

[ext_resource type="Script" uid="uid://dm2npmp455k7o" path="res://homemade_systems/wobbly_poly/wobble_polygon_2d.gd" id="1_3q1ym"]

[sub_resource type="Shader" id="Shader_3q1ym"]
code = "
shader_type canvas_item;

uniform float points_intensity : hint_range(0.0, 20.0) = 4.0;
uniform float whole_intensity : hint_range(0.0, 10.0) = 0.5;
uniform float speed : hint_range(0.1, 5.0) = 1.0;
uniform float wobble_seed : hint_range(0.0, 1000.0) = 0.0;
uniform float time_offset : hint_range(0.0, 10000.0) = 1000.0;
uniform float whole_wobble_off_seed : hint_range(0.0, 100.0) = 0.0;
uniform float whole_wobble_speed_seed : hint_range(0.5, 2.5) = 1.5;
uniform bool apply_whole_wobble_to_position = false;
uniform vec2 parent_wobble_offset = vec2(0.0, 0.0);

varying vec2 world_vertex;

// Hash function to create consistent vertex indexing
float hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

void vertex() {
    vec2 original_pos = VERTEX;

    // Calculate time with offset and speed - matching original secs calculation
    float secs = (TIME + time_offset) * speed;

    // Create consistent vertex index from position hash
    float vertex_hash = hash12(original_pos + vec2(wobble_seed));
    float i = vertex_hash * 1000.0; // Scale to get varied indices

    // EXACT match to original point wobble calculations
    float x_rate_off = sin(i) * 1.0;  // Your original used * 1
    float y_rate_off = cos(i) * 1.0;  // Your original used * 1

    // Point wobble - exact formula from original
    float new_point_x = original_pos.x + sin(secs * (2.0 + x_rate_off) + i) * points_intensity;
    float new_point_y = original_pos.y + cos(secs * (2.0 + y_rate_off) - i) * points_intensity;

    // Calculate whole wobble - exact formula from original
    float whole_wobble_x = sin(secs * whole_wobble_speed_seed + whole_wobble_off_seed) * whole_intensity;
    float whole_wobble_y = cos(secs * whole_wobble_speed_seed + whole_wobble_off_seed) * whole_intensity;

    // Apply wobbles based on mode
    if (apply_whole_wobble_to_position) {
        // When using position mode, only apply point wobble to vertices
        VERTEX = vec2(new_point_x, new_point_y) + parent_wobble_offset;
    } else {
        // When not using position mode, apply both wobbles to vertices
        VERTEX = vec2(new_point_x + whole_wobble_x, new_point_y + whole_wobble_y) + parent_wobble_offset;
    }

    world_vertex = VERTEX;
}

void fragment() {
    COLOR = texture(TEXTURE, UV) * COLOR;
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_nnlym"]
shader = SubResource("Shader_3q1ym")
shader_parameter/points_intensity = 0.5
shader_parameter/whole_intensity = 0.5
shader_parameter/speed = 2.0
shader_parameter/wobble_seed = 2.31544
shader_parameter/time_offset = 1000.0
shader_parameter/whole_wobble_off_seed = 37.2003
shader_parameter/whole_wobble_speed_seed = 2.24609
shader_parameter/apply_whole_wobble_to_position = false
shader_parameter/parent_wobble_offset = Vector2(0, 0)

[node name="WobblePolygon2D" type="Polygon2D"]
material = SubResource("ShaderMaterial_nnlym")
script = ExtResource("1_3q1ym")
points_intensity = 0.5
speed = 2.0
wobble_seed = 2.31544
